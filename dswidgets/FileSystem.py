# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_FileSystem.ipynb.

# %% auto 0
__all__ = ['get_cpu_model', 'cpu_use_stats', 'FolderSelector', 'Folder_Button', 'CPU_WIDGET']

# %% ../nbs/10_FileSystem.ipynb 5
import csv
import datetime  as dt
import panel     as pn
import psutil    as ps
import sys
import threading as th
import time

from collections import namedtuple


# %% ../nbs/10_FileSystem.ipynb 15
def get_cpu_model( ) ->str: # `"model name"` string.
  '''
  Reads `"/proc/cpuinfo"` and returns the `"model name"` string.
  '''
  with open('/proc/cpuinfo') as f:
    lines = f.readlines()
  for i in lines:
    i = i.strip()              # Remove CRLF
    t = i.split('\t:')         # Split string by '\t:'
    if len(t) >1:              # 
      if t[0] == 'model name': # If we find "model name"
        rv = t[1]              #  then put in `rv` break out and return `rv`
        break
  return rv

# %% ../nbs/10_FileSystem.ipynb 19
# return list has:
# scputimes(user=7815.26, nice=2.28, system=3641.48, idle=8743022.95, iowait=7.88, irq=0.0, softirq=669.33, steal=0.0, guest=0.0, guest_nice=0.0)
# wsl ww dt3 Execution time:
#   92.2 µs ± 17.8 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
def cpu_use_stats( # None
) -> tuple:  # A named tuple
  '''
  Returns CPU usage stats as a named tuple consisting of: 
  - totalsecs : Total CPU seconds the analysis is based on.
  - **all** : sum of: user+syst+iowait+softirq percent use.
  - **user** : user %
  - **system** : system %
  - **iowait** : iowait %
  - **softirq** : softirq %
  - **header** : A header string for str.
  - **str** : string variable with fully formatted values for each of above.
  '''
  v = ps.cpu_times()
  vtotal = 0.0
  for i in range(0,len(v)):
    vtotal += v[i]
  user    = 100*v.user/vtotal
  syst    = 100*v.system/vtotal
  iowait  = 100*v.iowait/vtotal
  softirq = 100*v.softirq/vtotal
  header  = 'Total time        All    User  System  IOwait softirq'
  str     = f'{vtotal/1e6:,f} sec  {user+syst+iowait+softirq:6.3f}% {user:6.3f}% { syst:6.3f}% {iowait:6.3f}% {softirq:6.3f}%'

  CPU_STATS = namedtuple('CPUStats', 'totalsecs all user system iowait softirq header str')
  cpu_stats = CPU_STATS(vtotal/1e6, user+syst+iowait+softirq, user, syst, iowait, softirq, header, str)
  return cpu_stats

# %% ../nbs/10_FileSystem.ipynb 27
def FolderSelector( parent,              # Parent widget
                   initial_dir='/',      # Dir to start in.
                   CallBack_func = None  # Function to call with selected folder.
                  ) ->object:            # The folder selector object
  """
  """
  def button_handler(event):
    floatpanel.status = 'closed'

    if event.obj.name   == 'Ok':
      parent.Selected_Folder = file_w._directory.value  
    elif event.obj.name == 'Cancel':
      parent.Selected_Folder = None

    if CallBack_func != None:
      CallBack_func( [parent.Selected_Folder, event]  )

  file_w          = pn.widgets.FileSelector(initial_dir,     root_directory ='/', refresh_period=500)
  FolderSel_b     = pn.widgets.Button(name='Ok',     button_type='primary')
  folder_cancel_b = pn.widgets.Button(name='Cancel', button_type='primary')
  folder_w        = pn.WidgetBox(file_w, pn.Row(FolderSel_b, folder_cancel_b) )
  floatpanel      = pn.layout.FloatPanel(folder_w, name='Basic FloatPanel', margin=20, contained=False, position='center')
  floatpanel.Selected_Folder = None
  FolderSel_b.on_click(    button_handler )
  folder_cancel_b.on_click( button_handler )
  parent.append( floatpanel )
  return floatpanel

# %% ../nbs/10_FileSystem.ipynb 31
class Folder_Button:
  def __init__(self, 
               name='Select Folder',  # Folder Selector button name
               initial_dir = '/',     # Initial directory
               call_back = None,      # Call this function with selection when done.               
              ):
    """
    """
    self.Selected_Folder = None
    self.value           = None
    self.initial_dir   = initial_dir
    self.call_back     = call_back
    self.folder_button = pn.Row()                 # We need a container. Can't use button
    self.button        = pn.widgets.Button(name=name)    # 
    self.button.on_click( self.Button_commands )
    self.folder_button.append( self.button )

  def My_callBack(self, v ):
    self.value           = self.folder_button.Selected_Folder
    self.Selected_Folder = self.folder_button.Selected_Folder
    if self.call_back:
      self.call_back(self.value)
    
  def Button_commands(self, event ):
    self.w = FolderSelector( self.folder_button, 
                            initial_dir   = self.initial_dir,
                            CallBack_func = self.My_callBack )


# %% ../nbs/10_FileSystem.ipynb 38
class CPU_WIDGET:
  '''
  '''
  Run             = False
  thread          = None
  thread_start_return_value  = None
  loop_count      = 0
  update_interval = 1
  utc_stamp       = dt.datetime.utcnow()
  utc_stamp_str   = utc_stamp.strftime("%Y-%m%d %H:%M:%S UTC")
  cpu_load_txt    = ps.getloadavg()
  cpu_count       = ps.cpu_count(logical=False)
  cpu_model_str   = get_cpu_model()
  core_usage      = list( range(0, cpu_count))

  def update_cpu_bars(self, value=None):
    '''
    {self.cpu_model_str:40s}
    '''
    self.utc_stamp        = dt.datetime.utcnow()
    self.utc_stamp_str    = self.utc_stamp.strftime("%Y-%m%d %H:%M:%S UTC")
    self.cpu_load_txt     = ps.getloadavg()
    self.cpu_load_w.value = f'{self.utc_stamp_str} Load Avgs:{self.cpu_load_txt}  {self.cpu_model_str:40s}'
    self.core_usage = cpu_state = ps.cpu_percent(percpu=True, interval=None)
    for cpu in range(self.cpu_count):
      self.cpu_bar[cpu].value = cpu_state[cpu]

  def system_status_thread(self, v ):
    '''
    '''
    self.Run = True
    while self.Run:
      self.update_cpu_bars()
      time.sleep( self.update_interval )
      self.loop_count +=  1
    self.cpu_load_w.value = f"Update Task Terminated normally at: {self.utc_stamp_str} "

  def start_thread( self ):
    self.thread = th.Thread( target = self.system_status_thread, args=[1111] )
    self.thread_start_return_value = self.thread.start()
    print( self.thread_start_return_value )
    
  def show_status(self):
    print('      Thread Name                         Run  Alive    Loops  Interval')
    print(f'{self.thread.name:40} {self.Run}   {self.thread.is_alive()} {self.loop_count:8d}   {self.update_interval:3.1f} Sec')
      
  def __init__(self):
    '''
    '''
    self.cpu_count = ps.cpu_count(logical=False)
    self.cpu_bar   = list(range(0, self.cpu_count))
    for cpu in range(self.cpu_count):
      self.cpu_bar[cpu] = pn.indicators.LinearGauge(name='',
                              value           =30, 
                              colors          =[(0.5, 'lightgreen'), (0.75,'yellow'), (1.0,'red')],
                              needle_color    ='', 
                              show_boundaries =False, 
                              default_color   ='lightgreen',
                              bounds          =(0, 100),
                              width           =50,
                              height          =200,
                              format          ='',
                              title_size      ='0pt',
                              tick_size       ='0pt',
                              margin          =(5,10),
                             )

    self.cpu_load_w = pn.widgets.StaticText(name='', value='Not set')
    self.row_w = pn.Row(f"**CPU<br>Core<br>% usage<br>{self.cpu_count} Cores**", name = 'xxxx', styles={'background': 'lightgray'})
    for cpu in range(0,self.cpu_count):
      self.row_w.append( self.cpu_bar[cpu]  )
    self.update_cpu_bars()
    self.cpu_status_widget = pn.Column(self.cpu_load_w, self.row_w)
    self.start_thread()
            
